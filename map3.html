<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Map interactive — fenêtres de contenu</title>
<style>
  :root{
    --ui-bg: rgba(0,0,0,0.6);
    --ui-color: #fff;
    --player-size: 36px;
    --marker-size: 65px;
  }
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;}
  #app{height:100vh;display:flex;flex-direction:column;}
  #hud{
    position:fixed; left:10px; top:10px; z-index:30;
    background:var(--ui-bg); color:var(--ui-color); padding:8px 12px;border-radius:8px;
    font-size:14px; box-shadow:0 4px 12px rgba(0,0,0,.4);
    user-select:none;
  }
  #hud b{display:inline-block; min-width:80px;}
  #viewport{
    position:relative; flex:1; overflow:hidden; background:#222;
  }
  #map{
    position:absolute; left:0; top:0;
    transform-origin:0 0;
  }
  #player{
    position:absolute;
    width:var(--player-size); height:var(--player-size);
    margin-left: calc(var(--player-size) / -2);
    margin-top: calc(var(--player-size) / -2);
    z-index:40;
    cursor:grab;
    transition: transform .03s linear;
  }
  #player:active{cursor:grabbing;}
  .marker{
    position:absolute;
    width:var(--marker-size); height:var(--marker-size);
    margin-left: calc(var(--marker-size) / -2);
    margin-top: calc(var(--marker-size) / -2);
    z-index:35;
    pointer-events:auto;
    user-select:none;
  }
  /* ==================== MODALE ==================== */
  #modal{
    display:none; position:fixed; inset:0; z-index:100; 
    background: rgba(0,0,0,.7);
    align-items:center; justify-content:center;
    padding:20px;
  }
  #modalContent{
    background:#fff; color:#000;
    max-width:600px; max-height:80vh;
    overflow-y:auto;
    border-radius:10px;
    padding:20px;
    box-shadow:0 10px 40px rgba(0,0,0,.5);
    text-align:center;
  }
  #modalContent img{
    max-width:100%;
    height:auto;
    border-radius:8px;
    margin-bottom:12px;
  }
  #closeBtn{
    background:#222; color:#fff;
    border:none;
    padding:8px 16px;
    border-radius:6px;
    cursor:pointer;
    margin-top:10px;
  }
  #tips{
    position:fixed; right:10px; top:10px; z-index:30;
    background:var(--ui-bg); color:var(--ui-color); padding:8px 12px;border-radius:8px;
    font-size:13px; max-width:220px;
  }
  @media (max-width:600px){
    #hud {font-size:12px}
    :root{--player-size:28px; --marker-size:28px;}
  }
</style>
</head>
<body>
<div id="app">
  <div id="hud">
    <div><b>Position</b> <span id="pos">x:0, y:0</span></div>
    <div style="margin-top:6px"><b>Map</b> <span id="mapName"></span></div>
    <div style="margin-top:6px"><b>Lieu</b> <span id="locLabel"></span></div>
  </div>

  <div id="viewport">
    <div id="map">
      <img id="player" src="data:image/svg+xml;utf8,
        <svg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 24 24' fill='none' stroke='%23ffcc00' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='10' r='3.2' /><path d='M12 2v3M12 21v-3M20 12h-3M7 12H4M17.5 6.5L15.5 8.5M8.5 15.5L6.5 17.5M17.5 17.5L15.5 15.5M8.5 8.5L6.5 6.5' /></svg>" alt="player" draggable="false">
    </div>
  </div>

  <!-- Fenêtre modale -->
  <div id="modal">
    <div id="modalContent">
      <img id="modalImg" src="" alt="">
      <div id="modalText"></div>
      <button id="closeBtn" onclick="hideModal()">Fermer</button>
    </div>
  </div>
</div>

<script>
/* ==========================
   CONFIGURATION
   ========================== */
const MAPS = {
  "ville-centre": {
    id: "ville-centre",
    name: "Ville - Centre",
    bg: "Sous Map/Vert.png",
    width: 900,
    height: 900
  }
};

// Map de départ
let CURRENT_MAP_ID = "ville-centre";

/* Exemple : chaque lieu peut maintenant avoir :
   - type: 'info' → ouvrira une fenêtre dans la page
   - img: image à afficher
   - text: texte avec \n ou \n\n
*/
let LOCATIONS = [
  { x: 200, y: 200, img: "Map/QGPhilosophe.png", type: "info", 
    label:"QG du Philosophe",
    contentImg:"Map/QGPhilosophe.png",
    contentText:"Bienvenue dans le QG du Philosophe.\n\nIci, la pensée se construit à chaque pas.\nRéfléchis, doute, recommence." 
  },
  { x: 400, y: 400, img: "Map/CentredesLubies.png", type: "info", 
    label:"Centre des Lubies",
    contentImg:"Map/CentredesLubies.png",
    contentText:"Les lubies sont les étincelles de l'esprit.\n\nElles naissent du hasard et deviennent des idées." 
  }
];

const PLAYER_SPEED = 300;
const CLICK_RADIUS = 40;
const DETECTION_RADIUS = 60;

/* ========================== */
let state = {
  mapObj: null,
  player: { x: 100, y: 100 },
  keys: {},
  lastTs: null,
  dragging: false
};

/* DOM elements */
const viewport = document.getElementById('viewport');
const mapEl = document.getElementById('map');
const playerEl = document.getElementById('player');
const posEl = document.getElementById('pos');
const mapNameEl = document.getElementById('mapName');
const locLabelEl = document.getElementById('locLabel');
const modal = document.getElementById('modal');
const modalImg = document.getElementById('modalImg');
const modalText = document.getElementById('modalText');

/* Charger une map */
function loadMap(mapIdOrObj){
  const mapObj = (typeof mapIdOrObj === 'string') ? MAPS[mapIdOrObj] : mapIdOrObj;
  if(!mapObj){ console.error("Map introuvable :", mapIdOrObj); return; }
  state.mapObj = mapObj;
  mapEl.style.width = mapObj.width + "px";
  mapEl.style.height = mapObj.height + "px";
  mapEl.style.backgroundImage = `url("${mapObj.bg}")`;
  mapEl.style.backgroundSize = "cover";
  mapNameEl.textContent = mapObj.name || mapObj.id || "";
  renderMarkers();
  clampPlayer();
  centerOnPlayer();
}

/* Rendu des marqueurs */
function renderMarkers(){
  mapEl.querySelectorAll('.marker').forEach(n => n.remove());
  LOCATIONS.forEach((loc, idx) => {
    const i = document.createElement('img');
    i.src = loc.img;
    i.className = 'marker';
    i.style.left = loc.x + 'px';
    i.style.top = loc.y + 'px';
    i.alt = loc.label || ("loc"+idx);
    i.dataset.idx = idx;
    i.addEventListener('click', (ev) => {
      ev.stopPropagation();
      handleLocationClick(loc);
    });
    i.addEventListener('mouseenter', () => locLabelEl.textContent = loc.label);
    i.addEventListener('mouseleave', () => locLabelEl.textContent = "");
    mapEl.appendChild(i);
  });
}

/* Action selon le type */
function handleLocationClick(loc){
  if(!loc) return;
  switch(loc.type){
    case 'info':
      showModal(loc.contentImg, loc.contentText);
      break;
    case 'map':
      if(MAPS[loc.link]) loadMap(loc.link);
      else if (loc.link.endsWith('.html')) window.location.href = loc.link;
      break;
    default:
      console.warn("Type non géré:", loc.type);
  }
}

/* Affichage du modal */
function showModal(imgSrc, text){
  modal.style.display = 'flex';
  modalImg.src = imgSrc || '';
  modalText.innerHTML = formatText(text || '');
}

/* Masquer le modal */
function hideModal(){
  modal.style.display = 'none';
  modalImg.src = '';
  modalText.textContent = '';
}

/* Formater le texte : \n = <br>, \n\n = <br><br> */
function formatText(str){
  return str
    .replace(/\n\s*\n/g, '<br><br>')
    .replace(/\\n/g, '<br>');
}

/* Centrage sur le joueur */
function centerOnPlayer(){
  const vpW = viewport.clientWidth;
  const vpH = viewport.clientHeight;
  const mapW = mapEl.clientWidth;
  const mapH = mapEl.clientHeight;
  let offsetX = vpW/2 - state.player.x;
  let offsetY = vpH/2 - state.player.y;
  offsetX = Math.min(0, Math.max(vpW - mapW, offsetX));
  offsetY = Math.min(0, Math.max(vpH - mapH, offsetY));
  mapEl.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
  playerEl.style.left = state.player.x + 'px';
  playerEl.style.top = state.player.y + 'px';
}

/* Limiter les coordonnées */
function clampPlayer(){
  if(!state.mapObj) return;
  state.player.x = Math.max(0, Math.min(state.mapObj.width, state.player.x));
  state.player.y = Math.max(0, Math.min(state.mapObj.height, state.player.y));
}

/* Déplacement clavier */
window.addEventListener('keydown', (e)=> state.keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', (e)=> state.keys[e.key.toLowerCase()] = false);

/* Drag */
let dragOffset = {x:0,y:0};
playerEl.addEventListener('pointerdown', (ev)=>{
  ev.preventDefault();
  playerEl.setPointerCapture(ev.pointerId);
  state.dragging = true;
  dragOffset.x = ev.clientX;
  dragOffset.y = ev.clientY;
});
playerEl.addEventListener('pointermove', (ev)=>{
  if(!state.dragging) return;
  const dx = ev.clientX - dragOffset.x;
  const dy = ev.clientY - dragOffset.y;
  state.player.x += dx;
  state.player.y += dy;
  dragOffset.x = ev.clientX;
  dragOffset.y = ev.clientY;
  clampPlayer();
  centerOnPlayer();
  updateHUD();
});
playerEl.addEventListener('pointerup', (ev)=>{
  state.dragging = false;
  try{ playerEl.releasePointerCapture(ev.pointerId);}catch(e){}
});

/* HUD dynamique */
function updateHUD(){
  posEl.textContent = `x:${Math.round(state.player.x)} y:${Math.round(state.player.y)}`;
  let nearest = null, bestDist = Infinity;
  LOCATIONS.forEach(loc => {
    const d = Math.hypot(state.player.x - loc.x, state.player.y - loc.y);
    if (d < bestDist) { bestDist = d; nearest = loc; }
  });
  locLabelEl.textContent = (nearest && bestDist < DETECTION_RADIUS) ? nearest.label : "";
}

/* Boucle principale */
function loop(ts){
  if(!state.lastTs) state.lastTs = ts;
  const dt = (ts - state.lastTs) / 1000;
  state.lastTs = ts;
  let dx = 0, dy = 0;
  if(state.keys['arrowup'] || state.keys['w']) dy -= 1;
  if(state.keys['arrowdown'] || state.keys['s']) dy += 1;
  if(state.keys['arrowleft'] || state.keys['a']) dx -= 1;
  if(state.keys['arrowright'] || state.keys['d']) dx += 1;
  if(dx || dy){
    const len = Math.hypot(dx,dy) || 1;
    state.player.x += (dx/len) * PLAYER_SPEED * dt;
    state.player.y += (dy/len) * PLAYER_SPEED * dt;
    clampPlayer();
    centerOnPlayer();
    updateHUD();
  } else updateHUD();
  requestAnimationFrame(loop);
}

/* Initialisation */
function init(){
  loadMap(CURRENT_MAP_ID);
  // On centre le joueur au milieu de la carte
  state.player.x = state.mapObj.width / 2;
  state.player.y = state.mapObj.height / 2;

  // On attend que la map soit bien rendue avant de centrer
  requestAnimationFrame(() => {
    centerOnPlayer();
    updateHUD();
    requestAnimationFrame(loop);
  });
}

init();
</script>
</body>
</html>
